from jazzstock_bot.common import connector_db as db
import time
from datetime import datetime as dt


def analysisSndBasicEachDay(stockcode, date):
    query = '''
INSERT INTO jazzdb.T_STOCK_SND_ANALYSIS_LONGTERM
SELECT RS.STOCKCODE, RS.DATE 

    ,ROUND(I80/SHARE,5) AS I80
    ,ROUND(I120/SHARE,5) AS I120
    ,ROUND(I160/SHARE,5) AS I160
    ,ROUND(I200/SHARE,5) AS I200
    ,ROUND(I240/SHARE,5) AS I240

    ,ROUND(F80/SHARE,5) AS F80
    ,ROUND(F120/SHARE,5) AS F120
    ,ROUND(F160/SHARE,5) AS F160
    ,ROUND(F200/SHARE,5) AS F200
    ,ROUND(F240/SHARE,5) AS F240

	,ROUND((CLOSE-C80)/C80,5) AS P80
    ,ROUND((CLOSE-C120)/C120,5) AS P120
    ,ROUND((CLOSE-C160)/C160,5) AS P160
    ,ROUND((CLOSE-C200)/C200,5) AS P200
    ,ROUND((CLOSE-C240)/C240,5) AS P240
    
    ,ROUND(YG80/SHARE,5) AS YG80
    ,ROUND(YG120/SHARE,5) AS YG120
    ,ROUND(YG160/SHARE,5) AS YG160
    ,ROUND(YG200/SHARE,5) AS YG200
    ,ROUND(YG240/SHARE,5) AS YG240

    ,ROUND(S80/SHARE,5) AS S80
    ,ROUND(S120/SHARE,5) AS S120
    ,ROUND(S160/SHARE,5) AS S160
    ,ROUND(S200/SHARE,5) AS S200
    ,ROUND(S240/SHARE,5) AS S240


FROM

(

	SELECT A.STOCKCODE, A.DATE, ABS(A.CLOSE) AS CLOSE, C.SHARE+0.01 AS SHARE, B.CNT

		, SUM(ABS(A.CLOSE)) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 80 PRECEDING AND 80 PRECEDING) AS C80
		, SUM(ABS(A.CLOSE)) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 120 PRECEDING AND 120 PRECEDING) AS C120
		, SUM(ABS(A.CLOSE)) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 160 PRECEDING AND 160 PRECEDING) AS C160
		, SUM(ABS(A.CLOSE)) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 200 PRECEDING AND 200 PRECEDING) AS C200
		, SUM(ABS(A.CLOSE)) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 240 PRECEDING AND 240 PRECEDING) AS C240


		# 3,5,10,20 누적 매수
		, A.INS AS I1	
		, SUM(A.INS) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 79 PRECEDING AND CURRENT ROW) AS I80
		, SUM(A.INS) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 119 PRECEDING AND CURRENT ROW) AS I120
		, SUM(A.INS) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 159 PRECEDING AND CURRENT ROW) AS I160
		, SUM(A.INS) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 199 PRECEDING AND CURRENT ROW) AS I200
		, SUM(A.INS) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 239 PRECEDING AND CURRENT ROW) AS I240

		, A.FOREI AS F1
		, SUM(A.FOREI) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 79 PRECEDING AND CURRENT ROW) AS F80
		, SUM(A.FOREI) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 119 PRECEDING AND CURRENT ROW) AS F120
		, SUM(A.FOREI) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 159 PRECEDING AND CURRENT ROW) AS F160
		, SUM(A.FOREI) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 199 PRECEDING AND CURRENT ROW) AS F200
		, SUM(A.FOREI) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 239 PRECEDING AND CURRENT ROW) AS F240
		
		
        , A.YG AS YG1
        , SUM(A.YG) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 79 PRECEDING AND CURRENT ROW) AS YG80
        , SUM(A.YG) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 119 PRECEDING AND CURRENT ROW) AS YG120
        , SUM(A.YG) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 159 PRECEDING AND CURRENT ROW) AS YG160
        , SUM(A.YG) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 199 PRECEDING AND CURRENT ROW) AS YG200
        , SUM(A.YG) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 239 PRECEDING AND CURRENT ROW) AS YG240

        , A.SAMO AS S1
        , SUM(A.SAMO) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 79 PRECEDING AND CURRENT ROW) AS S80
        , SUM(A.SAMO) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 119 PRECEDING AND CURRENT ROW) AS S120
        , SUM(A.SAMO) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 159 PRECEDING AND CURRENT ROW) AS S160
        , SUM(A.SAMO) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 199 PRECEDING AND CURRENT ROW) AS S200
        , SUM(A.SAMO) OVER (PARTITION BY A.STOCKCODE ORDER BY DATE ASC ROWS BETWEEN 239 PRECEDING AND CURRENT ROW) AS S240


	FROM jazzdb.T_STOCK_SND_DAY A
	JOIN jazzdb.T_DATE_INDEXED B USING (DATE)

    LEFT JOIN (

            SELECT STOCKCODE, SHARE, DATE
            FROM
            (
				SELECT STOCKCODE, SHARE, DATE
				FROM jazzdb.T_STOCK_SHARES_INFO
				WHERE 1=1
				AND HOLDER = '유통주식수'
			) T1

            WHERE 1=1

    ) C USING (STOCKCODE, DATE)

	WHERE 1=1
	AND A.STOCKCODE = '%s'
	AND B.CNT < 800
) RS

WHERE SHARE IS NOT NULL
AND RS.CNT=0


;

;

''' % (stockcode)

    db.insert(query)
#    time.sleep(50)

def db_readAll(dt):
    # DB에서 [종목명,종목코드] 로 구성된 데이터셋을 받아옴.
    # dbUpdateDate = db.selectSingleValue('SELECT max(date) FROM test.t_stock_shares_info')

    query = """

                        SELECT A.STOCKCODE, A.STOCKNAME
                        FROM jazzdb.T_STOCK_CODE_MGMT A
                        WHERE 1=1
                        AND A.STOCKCODE NOT IN (

                            SELECT STOCKCODE
                            FROM jazzdb.T_STOCK_SND_ANALYSIS_LONGTERM
                            WHERE DATE = '%s'
                            GROUP BY STOCKCODE
                        )
                        AND A.LISTED = 1
                                                        """ % (dt)

    for eachRow in db.select(query):
        if (len(eachRow) > 0):
            itemDic[eachRow[1].upper()] = eachRow[0]
            codeDic[eachRow[0]] = eachRow[1].upper()

    print("[INFO] 종목명/종목코드를 메모리에 읽어왔습니다, 남은 종목 수: ", len(itemDic.keys()))



def gettoday():
    td = db.selectSingleValue('SELECT cast(DATE AS CHAR) AS DATE FROM jazzdb.T_DATE_INDEXED WHERE CNT = 0')
    return td

itemDic = {}
codeDic = {}

start = dt.now()
todaydate = gettoday()

db_readAll(todaydate)
for i, eachCode in enumerate(codeDic.keys()):

    try:
        analysisSndBasicEachDay(eachCode, todaydate)
        if (i % 10 == 0):
            print(i, todaydate, eachCode, dt.now() - start)
    except:
        print('error', todaydate, eachCode, )
