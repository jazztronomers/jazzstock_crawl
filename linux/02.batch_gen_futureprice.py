from jazzstock_bot.common import connector_db as db
from datetime import datetime as dt



dq = '''

DELETE FROM jazzdb.T_STOCK_FUTURE_PRICE
WHERE DATE IN
(
	SELECT DATE
	FROM jazzdb.T_DATE_INDEXED
	WHERE CNT BETWEEN 0 AND 61
)

'''


db.delete(dq)


def db_readAll():
    # DB에서 [종목명,종목코드] 로 구성된 데이터셋을 받아옴.
    # dbUpdateDate = db.selectSingleValue('SELECT max(date) FROM test.t_stock_shares_info')

    query = """

                        SELECT A.STOCKCODE, A.STOCKNAME
                        FROM jazzdb.T_STOCK_CODE_MGMT A
                        WHERE 1=1
                        AND A.LISTED = 1
                                                        """

    for eachRow in db.select(query):
        if (len(eachRow) > 0):
            itemDic[eachRow[1].upper()] = eachRow[0]
            codeDic[eachRow[0]] = eachRow[1].upper()

    print("[INFO] 종목명/종목코드를 메모리에 읽어왔습니다, 남은 종목 수: ", len(itemDic.keys()))
    
codeDic, itemDic = {}, {}
db_readAll()
    


for i,each in enumerate(codeDic.keys()):
    query = '''

        INSERT INTO jazzdb.T_STOCK_FUTURE_PRICE
            (STOCKCODE, DATE,PRA1,PRA3,PRA5,PRA10,PRA20,PRA60
                            ,PRO1,PRO3,PRO5,PRO10,PRO20,PRO60
                            ,PRH1,PRH3,PRH5,PRH10,PRH20,PRH60
                            ,PRL1,PRL3,PRL5,PRL10,PRL20,PRL60)
        SELECT STOCKCODE, DATE
            ,FORMAT((PA1-CLOSE)/(CLOSE+0.01),3) AS PRA1
            ,FORMAT((PA3-CLOSE)/(CLOSE+0.01),3) AS PRA3
            ,FORMAT((PA5-CLOSE)/(CLOSE+0.01),3) AS PRA5
            ,FORMAT((PA10-CLOSE)/(CLOSE+0.01),3) AS PRA10
            ,FORMAT((PA20-CLOSE)/(CLOSE+0.01),3) AS PRA20
            ,FORMAT((PA60-CLOSE)/(CLOSE+0.01),3) AS PRA60

            ,FORMAT((PA1-OPEN_TOMORROW)/ (OPEN_TOMORROW+0.01),3) AS PRO1
            ,FORMAT((PA3-OPEN_TOMORROW)/ (OPEN_TOMORROW+0.01),3) AS PRO3
            ,FORMAT((PA5-OPEN_TOMORROW)/ (OPEN_TOMORROW+0.01),3) AS PRO5
            ,FORMAT((PA10-OPEN_TOMORROW)/(OPEN_TOMORROW+0.01),3) AS PRO10
            ,FORMAT((PA20-OPEN_TOMORROW)/(OPEN_TOMORROW+0.01),3) AS PRO20
            ,FORMAT((PA60-OPEN_TOMORROW)/(OPEN_TOMORROW+0.01),3) AS PRO60

            ,FORMAT((PH1-OPEN_TOMORROW)/(OPEN_TOMORROW+0.01),3) AS PRH1
            ,FORMAT((PH3-OPEN_TOMORROW)/(OPEN_TOMORROW+0.01),3) AS PRH3
            ,FORMAT((PH5-OPEN_TOMORROW)/(OPEN_TOMORROW+0.01),3) AS PRH5
            ,FORMAT((PH10-OPEN_TOMORROW)/(OPEN_TOMORROW+0.01),3) AS PRH10
            ,FORMAT((PH20-OPEN_TOMORROW)/(OPEN_TOMORROW+0.01),3) AS PRH20
            ,FORMAT((PH60-OPEN_TOMORROW)/(OPEN_TOMORROW+0.01),3) AS PRH60

            ,FORMAT((PL1-OPEN_TOMORROW)/(OPEN_TOMORROW+0.01),3) AS PRL1
            ,FORMAT((PL3-OPEN_TOMORROW)/(OPEN_TOMORROW+0.01),3) AS PRL3
            ,FORMAT((PL5-OPEN_TOMORROW)/(OPEN_TOMORROW+0.01),3) AS PRL5
            ,FORMAT((PL10-OPEN_TOMORROW)/(OPEN_TOMORROW+0.01),3) AS PRL10
            ,FORMAT((PL20-OPEN_TOMORROW)/(OPEN_TOMORROW+0.01),3) AS PRL20
            ,FORMAT((PL60-OPEN_TOMORROW)/(OPEN_TOMORROW+0.01),3) AS PRL60


        FROM
        (

            SELECT STOCKCODE, DATE, CLOSE, OPEN, HIGH, LOW
                , ROW_NUMBER() OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC) AS RN
                , SUM(CLOSE) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING) AS PA1
                , SUM(CLOSE) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 3 PRECEDING AND 3 PRECEDING) AS PA3
                , SUM(CLOSE) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 5 PRECEDING AND 5 PRECEDING) AS PA5
                , SUM(CLOSE) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 10 PRECEDING AND 10 PRECEDING) AS PA10
                , SUM(CLOSE) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 20 PRECEDING AND 20 PRECEDING) AS PA20
                , SUM(CLOSE) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 60 PRECEDING AND 60 PRECEDING) AS PA60

                , SUM(OPEN) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING) AS OPEN_TOMORROW


                , MAX(HIGH) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING) AS PH1
                , MIN(LOW) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING) AS PL1

                , MAX(HIGH) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 3 PRECEDING AND 1 PRECEDING) AS PH3
                , MIN(LOW) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 3 PRECEDING AND 1 PRECEDING) AS PL3

                , MAX(HIGH) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 5 PRECEDING AND 1 PRECEDING) AS PH5
                , MIN(LOW) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 5 PRECEDING AND 1 PRECEDING) AS PL5

                , MAX(HIGH) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 10 PRECEDING AND 1 PRECEDING) AS PH10
                , MIN(LOW) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 10 PRECEDING AND 1 PRECEDING) AS PL10

                , MAX(HIGH) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 20 PRECEDING AND 1 PRECEDING) AS PH20
                , MIN(LOW) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 20 PRECEDING AND 1 PRECEDING) AS PL20

                , MAX(HIGH) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 60 PRECEDING AND 1 PRECEDING) AS PH60
                , MIN(LOW) OVER (PARTITION BY STOCKCODE ORDER BY DATE DESC ROWS BETWEEN 60 PRECEDING AND 1 PRECEDING) AS PL60

            FROM jazzdb.T_STOCK_OHLC_DAY A
            JOIN jazzdb.T_DATE_INDEXED B USING (DATE)
            JOIN jazzdb.T_STOCK_CODE_MGMT USING (STOCKCODE)
            WHERE 1=1
            AND LISTED = 1
            AND B.CNT BETWEEN 0 AND 61
            AND STOCKCODE = '%s'
        ) RS;
        ;


            ''' %(each)

    try:
        db.insert(query)
        # print('FP SUCCESS', i,each,codeDic[each])
    except:
        print('ERROR', i,each, codeDic[each])